\chapter{Design}\label{chap:design}

\section{Emulator}

Der Emulator umfasst alles, was zur Simulation der Intel 8080 CPU beiträgt. Dabei handelt es sich hauptsächlich um das Ausführen von Instruktionen, das Interrupt-Handling sowie die Anbindung von Ein- und Ausgabegeräten.

\subsection{Zentrale Struktur}

\begin{listing}[ht]
\begin{minted}{rust}
    struct Emulator {
        pc: u16,
        sp: u16,
        ram: RAM,
        reg: RegisterArray,
        input_devices: [InputDevice; 256],
        output_devices: [OutputDevice; 256],
        running: bool,
        interrupts_enabled: bool
    }
\end{minted}
\centering
\caption{Zentrale Emulator Struktur}
\label{lst:wtf}
\end{listing}

Den Kern des Emulators bildet eine Struktur, welche zuständig für die Ausführung der Maschinencode-Programme ist. Sie gruppiert alle notwendigen Komponenten eines Intel 8080 Systems. Der Aufbau der Struktur ist in \cref{lst:wtf} illustriert.

Diese Komponenten wurden in \cref{chap:prereqs} bereits erklärt: \rust{pc} und \rust{sp} sind 2 16-Bit-Zahlen, die den \ac{PC} und den \ac{SP} repräsentieren. \rust{ram} ist der Arbeitsspeicher und \rust{reg} simuliert die Register (inklusive Flags und Akkumulator).
Die Ports für I/O-Geräte werden durch 2 Arrays mit jeweils 256 Elementen repräsentiert.
Darauf folgen zwei Boolean, einer sagt aus, ob der Emulator am Laufen ist und der andere gibt an, ob Interrupts erlaubt sind.


\subsection{Modularität}

Der Intel 8080 ist lediglich die CPU, RAM und I/O-Geräte arbeiten prinzipiell unabhängig. Diese müssen zwar eine entsprechende Schnittstelle bereitstellen um angeschlossen werden zu können, aber können beliebig implementiert sein. Unsere Implementierung ermöglicht verschiedene Implementierungen für RAM und Input/Output-Devices zu haben. Es handelt sich bei diesen Typen jedoch nicht um Interfaces, da Rust diese nicht unterstützt. Wie genau das in Rust umgesetzt ist, wird in \cref{chap:impl} erläutert. Prinzipiell ist die Funktionsweise identisch zu der klassischer Interfaces, aber ihre Implementierungen sind beliebig.

\subsection{Ausführung}

Die \rust{Emulator::execute_next()} Methode führt die Instruktion an der Addresse im PC aus. Der Opcode wird über ein enormes \rust{match}-Statement auf die entsprechende Funktion delegiert, die den Opcode ausführt. Diese Funktionen sind zuständig, den \ac{PC} entsprechend zu erhöhen. Abhängig vom ausgeführten Opcode muss dieser um 1, 2 oder 3 erhöht werden.

Der Rückgabetyp der Methode ist \rust{Result<(), &str>}, dadurch können entsprechende Fehlermeldungen nach außen propagiert werden. Dies ist wünschenswert, damit auf dem Frontend entsprechende Fehlermeldungen angezeigt werden können, um dem Benutzer den Entwicklungsprozess zu erleichtern.

\subsubsection{Instruktionen}

Um zu großen Dateien vorzubeugen, sind die Implementierungen der Instruktionen aufgeteilt in verschiedene Module. Sie sind logisch gruppiert in Arithmetik, Kontrollfluss, Logik, Speicherzugriff, Verschiebung und Speziell.
Obwohl die Funktionen in unterschiedlichen Dateien/Modulen deklariert sind, sind sie Methoden der \rust{Emulator}-Struktur.
Die verschiedenen Funktionen werden dann im Code von \rust{Emulator::execute_next()} aufgerufen.
Auch diese Funktionen geben häufig \rust{Result}s zurück, sofern die Ausführung in einem Fehler resultieren kann.

\subsection{Interrupts}

Über den \rust{interrupts_enabled}-Boolean wird geregelt, ob es erlaubt ist, Interrupts an den Emulator zu senden. Die Folgende Methode der zentralen Struktur wird verwendet, um Interrupts auszulösen:

\begin{minted}{rust}
    pub fn interrupt(&mut self, opcode: u8) -> EResult<usize> {
        if self.interrupts_enabled {
            self.interrupts_enabled = false;
            return self.execute_instruction(opcode);
        }
        Err("Interrupts disabled")
    }
\end{minted}

Wenn Interrupts erlaubt sind, wird der übergebene Opcode ausgeführt und der Boolean geflipped, andernfalls wird eine Errormeldung zurückgegeben. \rust{interrupts_enabled} ist initial \rust{false} und muss durch die entsprechende Instruktion (\asm{EI}) gesetzt werden.
Prinzipiell kann jede 1 Byte große Instruktion (parameterlose Instruktion) als Interrupt ausgeführt werden, meistens wird jedoch eine der \asm{RST}-Instruktionen ausgeführt. Diese sind \asm{CALL}-Instruktionen, die zu einer fixen Speicheradresse springen. An diesen fixen Adressen kann der Programmierer die entsprechenden Interrupt-Routinen platzieren.

\section{Assembler}

Für den Emulator und andere Konsumenten des Assemblers soll dieser eine einzelne, geschlossene Schnittstelle sein. Dabei vereint er unterschiedliche Funktionalitäten, die in drei Modulen realisiert werden. Es findet eine funktionelle Aufteilung in die folgenden Dateien statt:

\begin{itemize}
	\item Der eigentliche Assembler zum Übersetzen von Assemblycode und als öffentliche Schnittstelle
	\item Ein Präprozessor zur Behandlung von Pseudo-Instruktionen
	\item Ein Parser zur Auswertung numerischer Werte in unterschiedlichen Formaten
\end{itemize}

Um seine Funktionalität vollständig zu erfüllen soll der Assembler lediglich den vom Nutzer geschriebenen Code benötigen. Darauf aufbauend delegiert er dessen Verarbeitung intern mit Methodenaufrufen des Präprozessors.

Der Präprozessor ist eine \glqq Pure Fabrication\grqq{} für den Assembler. Zwar gibt es in Rust keine Klassen, die eigentlich solche reinen Erfindungen sind, in diesem Fall wird das Konzept von einer Datei umgesetzt. Dabei beinhaltet diese diverse Methoden zum Verarbeiten von Pseudo-Instruktionen, wie sie in Kapitel \ref{chap:pseudo-instructions} erläutert sind. Einzeln angewandt, sind die Methoden nur bedingt zu gebrauchen, da sie auf unterschiedlich weit verarbeitetem Code basieren. Deshalb übernimmt der Präprozessor die komplette Vorverarbeitung und bietet dafür die Methode \rust{get_preprocessed_code()} nach außen hin an. Auf dem an dieser Stelle überlieferten Quellcode basierend, erstellt die Methode einen Vektor von Instruktionen, die der Assembler in den entsprechenden Bytecode umwandeln kann.

Zusätzlich zur Verarbeitung von Pseudo-Befehlen, soll der Präprozessor das Erstellen einer Map ermöglichen, die einen Zusammenhang zwischen den erzeugten Bytes und den Zeilen, in denen sich der entsprechende Befehl befindet. Für diese Funktion bildet der Assembler entsprechend der Idee, die einzige Schnittstelle zu sein, einen Adapter für die Map, wodurch die interne Repräsentation und Implementierung unabhängig von Anforderungen bezüglich des Formats im Frontend wird.

Gemäß der Spezifikation erlaubt der Intel 8080 die Definition numerischer Werte in verschiedensten Formaten, unter anderem als mathematische Ausdrücke oder auch in Binärdarstellung. Um eine einheitliche Darstellung innerhalb von Rust zu gewährleisten und das Auslesen entsprechender Werte zu zentralisieren, nutzen sowohl Assembler als auch Präprozessor einen Parser. Ähnlich der zweiten Komponente handelt es sich hier um eine Pure Fabrication. Der entwickelte Parser, nimmt einen mathematischen Ausdruck als String entgegen und erzeugt davon ausgehend eine Menge Token, die stückweise abgearbeitet wird.

\section{Disassembler}

Ein Disassembler übersetzt Maschinencode zurück nach Assembly. Damit kann er zum Beispiel verwendet werden, um fremde Programme verständlich zu machen.
Die Funktionsweise des Disassemblers ist sehr simpel: Die Eingabe wird Byte für Byte durchlaufen, durch ein großes Match-Statement wird der Opcode unterschieden und entsprechend des Opcodes werden 0, 1 oder 2 Bytes an Parametern gelesen. Der Opcode und die Parameter werden dann benutzt, um die entsprechende Assembly Instruktion als String zu erzeugen.

\begin{minted}{rust}
fn decode_next(&mut self) -> Result<String, &'static str> {
    // Get next Opcode
    let instr = self.read_byte();
    match instr {
        0x00 => Ok(String::from("NOP")),
        0x01 => Ok(format!(
            "LXI B,{}",
            Disassembler::fmt_hex::<u16>(self.read_addr())
        )),
        // ...
}
\end{minted}

Der Disassembler liefert einen Iterator über \rust{Result<String, &'static str>}, wobei die Results die einzelnen Zeilen des Assembly Programmes enthalten. Der Iterator läuft bis die Eingabe vollständig abgearbeitet ist.

\section{WebAssembly API}

\section{Frontend}
