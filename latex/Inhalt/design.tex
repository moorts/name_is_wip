\chapter{Design}\label{chap:design}

\section{Emulator}

Der Emulator umfasst alles, was zur Simulation der Intel 8080 CPU beiträgt. Dabei handelt es sich hauptsächlich um das Ausführen von Instruktionen, das Interrupt-Handling sowie die Anbindung von Ein- und Ausgabegeräten.

\subsection{Zentrale Struktur}

\begin{listing}[ht]
\begin{minted}{rust}
    struct Emulator {
        pc: u16,
        sp: u16,
        ram: RAM,
        reg: RegisterArray,
        input_devices: [InputDevice; 256],
        output_devices: [OutputDevice; 256],
        running: bool,
        interrupts_enabled: bool
    }
\end{minted}
\centering
\caption{Zentrale Emulator Struktur}
\label{lst:wtf}
\end{listing}

Den Kern des Emulators bildet eine Struktur, welche zuständig für die Ausführung der Maschinencode-Programme ist. Sie gruppiert alle notwendigen Komponenten eines Intel 8080 Systems. Der Aufbau der Struktur ist in \cref{lst:wtf} illustriert.

Diese Komponenten wurden in \cref{chap:prereqs} bereits erklärt: \rust{pc} und \rust{sp} sind 2 16-Bit-Zahlen, die den \ac{PC} und den \ac{SP} repräsentieren. \rust{ram} ist der Arbeitsspeicher und \rust{reg} simuliert die Register (inklusive Flags und Akkumulator).
Die Ports für I/O-Geräte werden durch 2 Arrays mit jeweils 256 Elementen repräsentiert.
Darauf folgen zwei Boolean, einer sagt aus, ob der Emulator am Laufen ist und der andere gibt an, ob Interrupts erlaubt sind.


\subsection{Modularität}

Der Intel 8080 ist lediglich die CPU, RAM und I/O-Geräte arbeiten prinzipiell unabhängig. Diese müssen zwar eine entsprechende Schnittstelle bereitstellen um angeschlossen werden zu können, aber können beliebig implementiert sein. Unsere Implementierung ermöglicht verschiedene Implementierungen für RAM und Input/Output-Devices zu haben. Es handelt sich bei diesen Typen jedoch nicht um Interfaces, da Rust diese nicht unterstützt. Wie genau das in Rust umgesetzt ist, wird in \cref{chap:impl} erläutert. Prinzipiell ist die Funktionsweise identisch zu der klassischer Interfaces, aber ihre Implementierungen sind beliebig.

\subsection{Ausführung}

Die \rust{Emulator::execute_next()} Methode führt die Instruktion an der Addresse im PC aus. Der Opcode wird über ein enormes \rust{match}-Statement auf die entsprechende Funktion delegiert, die den Opcode ausführt. Diese Funktionen sind zuständig, den \ac{PC} entsprechend zu erhöhen. Abhängig vom ausgeführten Opcode muss dieser um 1, 2 oder 3 erhöht werden.

Der Rückgabetyp der Methode ist \rust{Result<(), &str>}, dadurch können entsprechende Fehlermeldungen nach außen propagiert werden. Dies ist wünschenswert, damit auf dem Frontend entsprechende Fehlermeldungen angezeigt werden können, um dem Benutzer den Entwicklungsprozess zu erleichtern.

\subsubsection{Instruktionen}

Um zu großen Dateien vorzubeugen, sind die Implementierungen der Instruktionen aufgeteilt in verschiedene Module. Sie sind logisch gruppiert in Arithmetik, Kontrollfluss, Logik, Speicherzugriff, Verschiebung und Speziell.
Obwohl die Funktionen in unterschiedlichen Dateien/Modulen deklariert sind, sind sie Methoden der \rust{Emulator}-Struktur.
Die verschiedenen Funktionen werden dann im Code von \rust{Emulator::execute_next()} aufgerufen.
Auch diese Funktionen geben häufig \rust{Result}s zurück, sofern die Ausführung in einem Fehler resultieren kann.

\subsection{Interrupts}

Über den \rust{interrupts_enabled}-Boolean wird geregelt, ob es erlaubt ist, Interrupts an den Emulator zu senden. Die Folgende Methode der zentralen Struktur wird verwendet, um Interrupts auszulösen:

\begin{minted}{rust}
    pub fn interrupt(&mut self, opcode: u8) -> EResult<usize> {
        if self.interrupts_enabled {
            self.interrupts_enabled = false;
            return self.execute_instruction(opcode);
        }
        Err("Interrupts disabled")
    }
\end{minted}

Wenn Interrupts erlaubt sind, wird der übergebene Opcode ausgeführt und der Boolean geflipped, andernfalls wird eine Errormeldung zurückgegeben. \rust{interrupts_enabled} ist initial \rust{false} und muss durch die entsprechende Instruktion (\asm{EI}) gesetzt werden.
Prinzipiell kann jede 1 Byte große Instruktion (parameterlose Instruktion) als Interrupt ausgeführt werden, meistens wird jedoch eine der \asm{RST}-Instruktionen ausgeführt. Diese sind \asm{CALL}-Instruktionen, die zu einer fixen Speicheradresse springen. An diesen fixen Adressen kann der Programmierer die entsprechenden Interrupt-Routinen platzieren.

\section{Assembler}

\section{Disassembler}

Ein Disassembler übersetzt Maschinencode zurück nach Assembly. Damit kann er zum Beispiel verwendet werden, um fremde Programme verständlich zu machen.
Die Funktionsweise des Disassemblers ist sehr simpel: Die Eingabe wird Byte für Byte durchlaufen, durch ein großes Match-Statement wird der Opcode unterschieden und entsprechend des Opcodes werden 0, 1 oder 2 Bytes an Parametern gelesen. Der Opcode und die Parameter werden dann benutzt, um die entsprechende Assembly Instruktion als String zu erzeugen.

\begin{minted}{rust}
fn decode_next(&mut self) -> Result<String, &'static str> {
    // Get next Opcode
    let instr = self.read_byte();
    match instr {
        0x00 => Ok(String::from("NOP")),
        0x01 => Ok(format!(
            "LXI B,{}",
            Disassembler::fmt_hex::<u16>(self.read_addr())
        )),
        // ...
}
\end{minted}

Der Disassembler liefert einen Iterator über \rust{Result<String, &'static str>}, wobei die Results die einzelnen Zeilen des Assembly Programmes enthalten. Der Iterator läuft bis die Eingabe vollständig abgearbeitet ist.

\section{WebAssembly API}

\section{Frontend}
