\chapter{Zukunftsideen}

Dieses Kapitel behandelt Ideen zur Erweiterung von \Emu. Dabei geht es sowohl um mögliche Erweiterungen der bestehenden Spezifikation, als auch Anpassungen die entsprechend dieser vorgenommen werden sollten, bzw. gemusst hätten, aber primär aus zeitlichen Gründen nicht mehr umzusetzen waren.

\section{Dynamic Recompilation}

Bei Dynamic Recompilation handelt es sich um eine Optimierungsstrategie, bei der Maschinencode des emulierten Systems auf Maschinencode des ausführenden Systems übersetzt wird. In unserem Fall würde dabei Intel 8080 Maschinencode zu WebAssembly kompiliert werden. Diese Rekompilation findet zur Laufzeit statt.

Das Ziel ist, Blöcke aus Intel8080 Assembly zu Blöcken aus nativem Assembly (in unserem Fall wäre das WebAssembly Bytecode) zu kompilieren und diese Blöcke in einem Cache zu speichern. Dies sähe ungefähr so aus\footnote{Dieses Beispiel ist orientiert an folgendem Blogpost: \url{https://wiki.pcsx2.net/PCSX2_Documentation/Introduction_to_Dynamic_Recompilation}}:


\begin{minted}{rust}
fn run() {
    let addr = getBlock(PC);
    // Execute instructions at addr in memory
    execute(addr);
}

fn getBlock(pc: u16) -> u64 {
    match cache[pc] {
        Some(addr) => addr,
        None => {
            let addr = recompileBlock(pc);
            cache[pc] = Some(addr);
            addr
        }
    }
}

fn recompileBlock(start_pc: u16) -> u64 {
    // Memory location the block will be written to
    let start_ptr = emitter.get_ptr();
    let pc = start_pc;
    loop {
        match opcodes[pc] {
            // Call emitter functions
            // Branching instructions will break the loop
        }
    }
    start_ptr
}
\end{minted}

Um den obigen Code zu realisieren, werden 2 Komponenten benötigt: der Code-Emitter und der Cache.

\subsection{Code-Emitter}

Der Code-Emitter hat die Funktion, die entsprechenden nativen Instruktionen auf Grundlage der 8080 Opcodes zu generieren. Dafür speichert er eine Adresse (\rust{emitter.get_ptr()} im obigen Code), wobei es sich um die Speicheradresse handelt, an die die nächste Instruktion geschrieben wird.

Der Emitter übersetzt im simpelsten Fall jeden Opcode in eine äquivalente Instruktion in nativen Assembly. Hier können allerdings auch Optimierungen stattfinden, die durch Verwendung eines moderneren Instruktionssatzes oder durch gesammelte Laufzeitinformationen möglich sind. Beispiele hierfür wären:

\begin{itemize}
    \item Zusammenfassung mehrerer 8/16-Bit Instruktionen als einzelne 32/64-Bit Instruktionen
    \item Verwendung von Instruktionen, die komplexere Prozesse (bspw. Stringkopie) realisieren
    \item Schleifenoptimierung
\end{itemize}

Der Emitter schreibt diese nativen Instruktionen an die gespeicherte Addresse, welche in den Cache zeigt.

\subsection{Cache}

Beim bereits erwähnten Cache handelt es sich lediglich um eine Speicherregion, die mit dem PC indiziert werden kann und entweder \rust{None} zurückgibt, wenn der entsprechende Maschinencode noch nicht generiert wurde, oder die entsprechend nächste Instruktion zurückgibt.


\section{Intel Hex}

Momentan gibt der Assembler einen Vektor aus Bytes zurück, welcher in den RAM des Emulators geladen wird um ein Programm zu laden. Ein alternatives Format für die Assembler-Ausgabe wäre das Intel Hex-Format, ein Dateiformat um Binärdaten im ASCII-Format zu speichern. In Intel Hex repräsentiert jede Zeile einen Datensatz, der eine konsekutive Bytefolge enthält. Ein solcher Datensatz enthält 6 Felder:

\begin{enumerate}
\item Satzbeginn: ein ASCII Doppelpunkt am Anfang der Zeile
\item Anzahl an Bytes: Wie viele Datenbytes enthalten sind
\item Speicheradresse: 16-Bit Adresse im Speicher, an der der Datenblock beginnt
\item Datensatztyp: 00..05
\item Daten: n Bytes (als 2n Hex-Zeichen kodiert)
\item Prüfsumme: 2 Hex-Zeichen große Prüfsumme über den Datensatz
\end{enumerate}

Dieses Format zu verwenden hat den Vorteil, leere Regionen zwischen Assembly Instruktionen nicht abspeichern zu müssen. Außerdem sind ROMs für den 8080 häufig in diesem Format vorliegend, daher wäre es sinnvoll solche Dateien einlesen zu können.

\section{Optimierung und Restrukturierung des Assemblers}

Die Entwicklung des Assemblers folgte einem iterativ, inkrementellen Ansatz. Dabei wurden schrittweise neue Funktionen hinzugefügt, wobei mit den einfachen Opcodes angefangen, dann zu Labels und später den Pseudo-Instruktionen übergegangen wurde. Was für die Entwicklung unproblematisch war machte sich jedoch vor allem zum Ende der Implementierung und bei der Dokumentation der Arbeit bemerkbar:

Die Struktur des Assemblers ist suboptimal. Zwar sind viele Funktionen in einzelnen Methoden gekapselt, allerdings gibt es potentielle Fehler in deren aktueller Anordnung. So ist es zum Zeitpunkt der Beendigung der Arbeit beispielsweise nicht möglich ein Label als Bedingung für einen If-Block zu verwenden. Zwar könnte der Code assembled werden, allerdings schlägt das Mapping von Zeilen fehl, weil für diese Makros nicht ersetzt werden, was aber notwendig für die Bestimmung von Labels ist.

In diesem Fall wurde sich dazu entschlossen den Fehler in Kauf zu nehmen. Begründet wird dies vor allem mit dem Verhältnis von Zeitaufwand und möglichem Gewinn: Zwar handelt es sich um einen kritischen Fehler, allerdings ist die Verwendung von Labels in konditionalen Anweisungen wenig sinnvoll. Schließlich ist nur das Label, das noch vor dem ersten Opcode steht, sofern es überhaupt existiert, null. In allen anderen Fällen sind Label ungleich null und damit konstante Werte, die die If-Bedingung erfüllen. Es erscheint, obwohl erlaubt, nur wenig sinnvoll Labels an einer solchen Stelle zu positionieren, weshalb der Fehler toleriert wird.

Neben solchen, durch Eckfälle bedingte Fehler, bietet der Assembler auch Raum für Optimierung. Das gilt bezüglich der Zeit- sowie der Codekomplexität. An Stellen, an denen dies bereits zum Zeitpunkt des Arbeitsabschlusses ersichtlich war, wurde das bereits in Kapitel \ref{chap:impl-assembler} erwähnt. Vor allem die zeitliche Abfolge zum Auslesen und Ersetzen bestimmter Zeileninhalte ist verbesserbar. Allerdings ist die Performanz des Assemblers bisher mehr als ausreichend, weswegen der Fokus nicht auf solchen Verbesserungen lag.
